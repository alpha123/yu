* Goals
Yu's primary use for random numbers is certain probabilistic data structures.
Cryptographically secure randomness is decidedly _not_ something I want to
tackleâ€”much smarter people have already done that. Cryptography functions should
wrap well-tested C libraries and go in the Yu stdlib; the Yu VM has no need for
cryptographically secure numbers.
** Speed > Security
Data structures such as skiplists and treaps don't need cryptographically secure
random numbers. They need numbers roughly fitting a given distribution, and they
need 'em *fast*.
*** Security?
For probabilistic data structures, the only attack vector I can think of is
somehow generating a seed or insertion order or something that degrades the
performance of, say, a skiplist from O(lg n) to O(n) and stages a
denial-of-service attack. This would be _very_ hard to pull off, much harder
than hash-collisions attacks. I /think/ the attacker would need control of the
random seed to attempt such an attack, so if the RNG is seeded on, say, time of
day such an attack is theoretically plausible. Actually managing to cause a
random sequence that turns a skiplist into an almost-flat linked list is very
likely not possible however. I think the possibility of a denial-of-service
attack based on probabilistic data structures using insecure random numbers is
ver, very slim, if possible at all.
** Single Bytes
Often a skiplist or treap only needs a single, random-ish byte. However, simply
generating an int32 and returning it as 4 bytes will screw up the distribution,
and such data structures rely on (relatively) uniform distributions for
performance. This'll require a little math to figure out.
** Tunable Distributions
The random distribution naturally has somewhat significant performance
implications on the performance of probabilistic structures. A flawed
distribution could reduce a skiplist to a linked list or severely unbalance a
treap. However, different data structures may fair better with a non-uniform
distribution. Allowing the API to be generic to random distribution seems like a
good idea.
** Integers Are Fine
Probabilistic data structures have no particular need of random floating point
values. Keep the API to ints to make testing easier and reduce complexity.

* API
** init
Like the allocator API, different RNGs may have different initialization
requirements and the yu_rand API imposes no particular requirements on how
generators are created.
** void free(yu_rand *rng);
De-init the rng, releasing any resources that initialization acquired.
** void seed(yu_rand *rng, u32 seed);
Should seed the rng appropriately such that different values of `seed` produce
different random sequences, but identical values _must_ produce the same
sequence. A single rng instance should be able to be seeded multiple times
without needing to be explicitly reinitialized. Resetting the seed must reset
the random sequence.
** s32 gen_s32(yu_rand *rng, s32 lower_bound, s32 upper_bound);
Return a number within the closed interval [lower_bound,upper_bound] obeying
this generator's distribution. `gen_s32() % diff` isn't gonna cut it.
** u8 gen_byte(yu_rand *rng);
Generate a single byte obeying this generator's distribution. It's fine for the
generator to make a bunch of bytes at once and cache them, but they still must
be distributed properly. i.e. making some 32-bit ints and naively splitting them
into byte arrays probably isn't gonna work.

Callers may depend on this function to be relatively fast. It should not perform
any memory allocations or other operations that may have unpredictable
performance impact.
** void gen_byte_array(yu_rand *rng, u8 *bytes_out, size_t num);
Generate many bytes at once. Unlike gen_byte(), this function has no particular
performance contract.

* Generator Implementation
A random number generator should be a structure type with its first member a
`struct yu_rand_funcs`.

#+BEGIN_SRC C
struct uniform_distribution {
  struct yu_rand_funcs base;  // Important: must be first member
  ...  // ex: sfmt_t rng;
};

yu_err uniform_distribution_init(struct uniform_distribution *rng) {
  rng->base.free = (yu_rand_free_fn)uniform_distribution_free;
  rng->base.seed = (yu_seed_fn)uniform_distribution_seed;
  ...
}

void uniform_distribution_seed(struct uniform_distribution *rng, u32 seed) {
  ...
}

// etc
#+END_SRC

* Provided Generators
The following are probably important to have by default.
** uniform_distribution
** normal_distribution
** poisson_distribution
I suspect skiplists might behave slightly better with a poisson distribution
than with a uniform distribution. Would be interesting to check.
